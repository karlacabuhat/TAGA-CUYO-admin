    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href='https://unpkg.com/boxicons@2.0.9/css/boxicons.min.css' rel='stylesheet'>
        <link rel="stylesheet" href="https://cdn.materialdesignicons.com/5.4.55/css/materialdesignicons.min.css">
        <link rel="stylesheet" href="https://unicons.iconscout.com/release/v4.0.0/css/line.css">
        <link rel="stylesheet" href="status.css">
        <title>Status</title>
    </head>
    <body>
    <!-- Firebase App (compat version) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>

    <!-- Firebase Firestore SDK (compat version) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>

    <!-- Firebase Auth SDK (compat version) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>


    <!-- SIDEBAR -->
     <!-- SIDEBAR -->
     <section id="sidebar">
        <a href="dashboard.html" class="brand"><img src="images/logo.png" width="70px" height="70px"> TAGA-CUYO</a>
        <ul class="side-menu">
            <li><a href="dashboard.html"><i class='bx bxs-dashboard icon'></i> Admin Dashboard</a></li>
            <li class="divider" data-text="main">Main</li>
            <li>
                <a href="#"><i class='bx bxs-inbox icon'></i> User Management <i class='bx bx-chevron-right icon-right'></i></a>
                <ul class="side-dropdown">
                    <li><a href="user_management_user.html" class="active"><i class='mdi mdi-account icon'></i> List of Users</a></li>
                    <li><a href="ManageStaff2.html"><i class='uil uil-users-alt icon'></i> Manage Staff</a></li>
                </ul>
            </li>
            <li>
                <a href="#"><i class='bx bxs-graduation icon' class="active"></i> Learning Feature Status <i class='bx bx-chevron-right icon-right'></i></a>
                <ul class="side-dropdown">
                    <li><a href="Pending.html" ><i class='bx bx-time icon'></i>Status</a></li>
                    <li><a href="lesson.html"><i class='bx bxs-book icon'></i>Aralin</a></li>
                    <li><a href="category.html"><i class='bx bxs-category icon'></i>Kategorya</a></li>
                </ul>
            </li>
            <li>
                <a href="#"><i class='bx bxs-comment icon'></i> Support and Feedback <i class='bx bx-chevron-right icon-right'></i></a>
                <ul class="side-dropdown">
                    <li><a href="feedback2.html" class="active"><i class='bx bxs-message-rounded icon'></i>User Feedback</a></li>
                    <li><a href="user_support.html"><i class='uil uil-headphones-alt icon'></i>User Support</a></li>
                </ul>
            </li>
            <li><a href="terms_and_condition.html"><i class='bx bxs-file icon'></i> Terms and Condition</a></li>
            <li><a href="settings2.html"><i class='bx bxs-cog icon'></i> Settings</a></li>
        </ul>
    </section>
    <!-- SIDEBAR -->

    <!-- NAVBAR -->
    <section id="content">
        <nav>
        <i class='bx bx-menu toggle-sidebar'></i>
        <form action="#">
            <div class="form-group">
                <input type="text" id="searchInput" placeholder="Search..." onkeyup="searchFeedback()">
                <i class='bx bx-search icon'></i>
            </div>
        </form>
        <div class="profile">
            <div class="notification-icon" onclick="toggleNotificationDropdown()">
                <i class='bx bxs-bell'></i>
                <span id="notificationCounter" class="notification-counter">0</span>
            </div>
            <div id="notificationDropdown" class="notification-dropdown hidden">
                <h4>Notifications</h4>
                <ul id="notificationList">
                    <!-- Notifications will be populated here -->
                </ul>
            </div>
            <img src="images/logo.png" alt="Profile Image">
            <ul class="profile-link">
                <li><a href="/settings2.html"><i class='bx bxs-cog'></i> Settings</a></li>
                <li><a href="login2.html"><i class='bx bxs-log-out-circle'></i> Logout</a></li>
            </ul>
            </div>
        </nav>
    <main>
        <hr class="custom-line">
                <div class="header-search">
                    <h2 style="color: rgb(135, 142, 142);">&nbsp;Learning Features Status</h2>
                </div>
            </hr>
            &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
            <h4 sty>Pending Learning Features</h4>
    <table id="pendingContentTable">
        <thead>
            <tr>
                <th style="text-align: center;">Lesson ID</th>
                <th style="text-align: center;">Lesson Name</th>
                <th style="text-align: center;">Content Details</th>
                <th style="text-align: center;">Image</th>
                <th style="text-align: center;">Requester's Action</th>
                <th style="text-align: center;">Timestamp</th>
                <th style="text-align: center;">Status</th>
                <th style="text-align: center;">Requester</th>
                <th style="text-align: center;">Action</th>
            </tr>
        </thead>
        <tbody id="pendingContentTableBody">
            <!-- Pending content entries will be appended here -->
        </tbody>
    </table>
    &nbsp;
    &nbsp;
    <h4>History of Actions</h4>
    <div style="max-height: 500px; overflow-y: auto; border: 1px;">
        <table id="historyTable" style="width: 100%;">
            <thead style="background-color: rgb(93, 141, 214); text-align: center;">
                <tr>
                    <th style="text-align: center;">Timestamp</th>
                    <th style="text-align: center;">Requester</th>
                    <th style="text-align: center;">Document ID</th>
                    <th style="text-align: center;">Lesson ID</th>
                    <th style="text-align: center;">Content Details</th>
                    <th style="text-align: center;">Requester's Action</th>
                    <th style="text-align: center;">Admin Action</th>
                </tr>
            </thead>
            <tbody id="historyTableBody">
                <!-- History entries will be appended here -->
            </tbody>
        </table>
    </div>


    </main>
    </section>

    <script type="module">
        document.addEventListener("DOMContentLoaded", loadPendingContent);
        document.addEventListener("DOMContentLoaded", loadHistory);
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
        import { getFirestore, collection, getDocs, doc, updateDoc, deleteDoc, getDoc, addDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";  // Import authentication module

        const firebaseConfig = {
            apiKey: "AIzaSyA_VoT0W3zD6u5GVEa24dLcMkt3DJtnqYg",
            authDomain: "tagalog-cuyonon-mobile-app.firebaseapp.com",
            projectId: "tagalog-cuyonon-mobile-app",
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth();
    onAuthStateChanged(auth, user => {
        if (user) {
            console.log('User is signed in:', user);
            // Proceed with Firestore operations
        } else {
            console.log('No user is signed in.');
        }

    });
    window.approveContent = async function(docId) {
    const docRef = doc(db, 'activities', docId);
    const docSnapshot = await getDoc(docRef);

    if (!docSnapshot.exists()) {
        console.error("No such document! Unable to update.");
        return;
    }

    const data = docSnapshot.data();
    const approveButton = document.querySelector(`button.approve-btn[data-doc-id="${docId}"]`);
    const rejectButton = document.querySelector(`button.reject-btn[data-doc-id="${docId}"]`);

    if (data.location === 'lesson' && data.lessonId) {
        // Approving a word for a lesson
        const lessonDocRef = doc(db, 'lessons', data.lessonId);
        const lessonDocSnapshot = await getDoc(lessonDocRef);

        if (lessonDocSnapshot.exists()) {
            const lesson_name = lessonDocSnapshot.data().lesson_name || 'N/A';

            const wordsSubcollectionRef = collection(lessonDocRef, 'words');
            await addDoc(wordsSubcollectionRef, {
                word: data.word,
                translated: data.translated,
                options: data.options ? data.options : [],
                addedBy: data.addedBy,
                timestamp: new Date(),
            });

            await updateDoc(lessonDocRef, {
                lesson_name: lesson_name,
                isApproved: true,
                lastUpdated: new Date(),
            });

            await updateDoc(docRef, { isApprove: true });
            removeFromPendingContentTable(docId);
            loadHistory();
        }

    } else if (data.location === 'category' && data.categoryId && data.subcategoryId) {
        // Approving a word for a category, specifically within a subcategory
        const categoryDocRef = doc(db, 'categories', data.categoryId);
        const subcategoryDocRef = doc(categoryDocRef, 'subcategories', data.subcategoryId);
        const subcategoryDocSnapshot = await getDoc(subcategoryDocRef);

        if (subcategoryDocSnapshot.exists()) {
            const wordsSubcollectionRef = collection(subcategoryDocRef, 'words');
            await addDoc(wordsSubcollectionRef, {
                word: data.word,
                translated: data.translated,
                options: data.options ? data.options : [],
                image_path: data.image_path,
                addedBy: data.addedBy,
                timestamp: new Date(),
            });

            await updateDoc(subcategoryDocRef, {
                isApproved: true,
                lastUpdated: new Date(),
            });

            await updateDoc(docRef, { isApprove: true });
            removeFromPendingContentTable(docId);
            loadHistory();
        } else {
            console.error("Subcategory does not exist! Unable to add word.");
        }
    }

    // Log the approval action in history
    await addDoc(collection(db, 'history'), {
        action: data.location === 'lesson' ? 'Added a word in lesson' : 'Added a word in category',
        addedBy: data.addedBy,
        lessonId: data.lessonId || data.categoryId,
        documentId: docId,
        contentDetails: `Word: ${data.word} <br> Translated: ${data.translated} <br> Options: ${data.options ? data.options.join(', ') : 'No options available'}`,
        adminAction: 'Added content',
        timestamp: new Date(),
    });

    // Remove from Pending Content Table
    removeFromPendingContentTable(docId);
    loadHistory();  // Reload history table
};

window.rejectContent = async function(docId) { 
    const docRef = doc(db, 'activities', docId);
    const docSnapshot = await getDoc(docRef);

    if (docSnapshot.exists()) {
        const data = docSnapshot.data();
        const contentDetails = `Word: ${data.word} <br> Translated: ${data.translated} <br> Options: ${data.options ? data.options.join(', ') : 'No options available'}`;

        if (data.location === 'lesson' && data.lessonId) {
            // Handling lesson content rejection
            const lessonDocRef = doc(db, 'lessons', data.lessonId);
            const lessonDocSnapshot = await getDoc(lessonDocRef);

            if (lessonDocSnapshot.exists()) {
                const wordsCollectionRef = collection(lessonDocRef, 'words');
                const wordSnapshot = await getDocs(wordsCollectionRef);

                // Iterate over words and delete matching word
                await Promise.all(wordSnapshot.docs.map(async (wordDoc) => {
                    const wordData = wordDoc.data();
                    if (wordData.word === data.word) {
                        await deleteDoc(wordDoc.ref);
                        console.log(`Deleted word: ${data.word} from lesson.`);
                    }
                }));
                 // Remove from Pending Content Table
    removeFromPendingContentTable(docId);
            }
        } else if (data.location === 'category' && data.categoryId && data.subcategoryId) {
            // Handling category content rejection
            const categoryDocRef = doc(db, 'categories', data.categoryId);
            const subcategoryDocRef = doc(categoryDocRef, 'subcategories', data.subcategoryId);
            const wordsCollectionRef = collection(subcategoryDocRef, 'words');
            const wordSnapshot = await getDocs(wordsCollectionRef);

            // Iterate over words and delete matching word in subcategory
            await Promise.all(wordSnapshot.docs.map(async (wordDoc) => {
                const wordData = wordDoc.data();
                if (wordData.word === data.word) {
                    await deleteDoc(wordDoc.ref);
                    console.log(`Deleted word: ${data.word} from category subcategory.`);
                }
            }));
            removeFromPendingContentTable(docId);
        }
      
        loadHistory();  // Reload history table for updated view

       // Log the rejection action in history
await addDoc(collection(db, 'history'), {
    action: data.location === 'lesson' ? 'Deleted a word in lesson' : 'Deleted a word from category',
    addedBy: data.addedBy || 'Unknown',  // Use 'Unknown' if addedBy is undefined
    lessonId: data.location === 'lesson' ? data.lessonId : data.categoryId,  // Log lessonId only if it's a lesson
    categoryId: data.location === 'category' ? data.categoryId : null, // Log categoryId if it's a category
    subcategoryId: data.location === 'category' ? data.subcategoryId : null, // Log subcategoryId if it's a category
    documentId: docId,
    contentDetails: `Word: ${data.word} <br> Translated: ${data.translated} <br> Options: ${data.options ? data.options.join(', ') : 'No options available'}`,
    adminAction: 'Deleted content',  // Describes the action taken
    timestamp: new Date(),
});

        // Remove the document from the 'activities' collection to clear it from the pending table
        await deleteDoc(docRef);
        console.log(`Removed rejected content with docId: ${docId} from activities.`);

        // Remove from Pending Content Table and reload history
        removeFromPendingContentTable(docId);
        loadHistory();  // Reload history table for updated view
    } else {
        console.error("Document does not exist in activities collection. Unable to reject.");
    }
};
window.dismissContent = async function(docId) { 
    console.log("Action dismissed. No changes made to the database.");
    const docRef = doc(db, 'activities', docId);
    const docSnapshot = await getDoc(docRef);

    // Ensure the document exists before proceeding
    if (!docSnapshot.exists()) {
        console.error("No such document! Unable to dismiss.");
        return;  // This return statement is now inside the function, which is correct.
    }

    // Extract the type from the document data (assumed to be available)
    const data = docSnapshot.data();
    const type = data.location === 'lesson' ? 'lesson' : 'category';  // Define 'type' based on document location

    try {
        await updateDoc(docRef, {
            isApprove: false,
            dismissed: true,
            contentType: type  // Use the defined 'type' (lesson or category)
        });
        alert('Content dismissed.');
    } catch (error) {
        console.error("Error dismissing content:", error);
        alert('Error dismissing content.');
    }

    const contentDetails = `Word: ${data.word} <br> Translated: ${data.translated} <br> Options: ${data.options ? data.options.join(', ') : 'No options available'}`;

    // Store dismissed content in localStorage
    let dismissedContent = JSON.parse(localStorage.getItem('dismissedContent')) || [];
    dismissedContent.push(docId);
    localStorage.setItem('dismissedContent', JSON.stringify(dismissedContent));

    // Remove the row from the pending content table
    const row = document.querySelector(`tr[data-doc-id="${docId}"]`);
    if (row) {
        alert('It has been dismissed! No changes made!');
        row.remove();
    }

    // Log the dismissal action in history
    await addDoc(collection(db, 'history'), {
        action: 'Dismissed content',
        addedBy: data.addedBy || 'Unknown',
        lessonId: data.location === 'lesson' ? data.lessonId : data.categoryId,
        documentId: docId,
        contentDetails: contentDetails,
        adminAction: 'Dismissed content',
        timestamp: new Date(),
    });

    // Reload history table (if applicable)
    loadHistory();
};

function removeFromPendingContentTable(docId) {
    const row = document.querySelector(`tr[data-doc-id="${docId}"]`);
    if (row) {
        row.remove();
    }
}

        let pendingContentCache = [];
        
        window.editWordContent = async function(docId, documentId, location, lessonId, categoryId) {
    try {
        // Handling lesson update (editing and approving the content)
        if (location === 'lesson') {
            const lessonDocRef = doc(db, 'lessons', lessonId); // Corrected: used lessonId instead of data.lessonId
            const lessonDocSnapshot = await getDoc(lessonDocRef);

            if (lessonDocSnapshot.exists()) {
                const wordsSubcollectionRef = collection(lessonDocRef, 'words'); // Reference to the 'words' subcollection
                const wordDocRef = doc(wordsSubcollectionRef, docId); // Reference to the specific word document

                // Check if document exists before updating
                const wordDocSnapshot = await getDoc(wordDocRef);
                if (wordDocSnapshot.exists()) {
                    // Update the word document (ensure 'approved' and 'edited' fields exist)
                    await updateDoc(wordDocRef, {
                        edited: true,  // Flag to indicate the word has been edited
                    });

                    console.log(`Word with ID ${docId} approved and updated successfully in lesson ${lessonId}`);

                    // Log the approval action in history
                    await addDoc(collection(db, 'history'), {
                        action: 'Approved and edited word in lesson',
                        addedBy: 'admin', // Adjust if needed to reflect who edited it
                        lessonId: lessonId, // Store lessonId from document
                        categoryId: null,
                        subcategoryId: null,
                        documentId: docId,
                        contentDetails: `Word ID: ${docId} approved and updated.`,
                        adminAction: 'Approved content',
                        timestamp: new Date(),
                    });
                } else {
                    console.error(`Word document with ID ${docId} not found in lesson.`);
                }
            } else {
                console.error('Lesson not found.');
            }
        }

        // Handling category update (editing and approving the content)
        if (location === 'category') {
            const categoryDocRef = doc(db, 'categories', categoryId); // Reference to the category document
            const categoryDocSnapshot = await getDoc(categoryDocRef);

            if (categoryDocSnapshot.exists()) {
                const subcategoryDocRef = doc(categoryDocRef, 'subcategories', docId); // Reference to the subcategory
                const wordCollectionRef = collection(subcategoryDocRef, 'words'); // Reference to the 'words' subcollection
                const wordDocRef = doc(wordCollectionRef, docId); // Reference to the specific word document

                // Check if document exists before updating
                const wordDocSnapshot = await getDoc(wordDocRef);
                if (wordDocSnapshot.exists()) {
                    // Update the word document (ensure 'approved' and 'edited' fields exist)
                    await updateDoc(wordDocRef, {
                        approved: true,  // Marking as approved
                        edited: true,  // Flag to indicate the word has been edited
                    });

                    console.log(`Word with ID ${docId} approved and updated successfully in category ${categoryId}`);

                    // Log the approval action in history
                    await addDoc(collection(db, 'history'), {
                        action: 'Approved and edited word in category',
                        addedBy: 'admin', // Adjust if needed
                        lessonId: null,
                        categoryId: categoryId, // Store categoryId from document
                        subcategoryId: docId, // Store subcategoryId (docId)
                        documentId: docId,
                        contentDetails: `Word ID: ${docId} approved and updated.`,
                        adminAction: 'Approved content',
                        timestamp: new Date(),
                    });
                } else {
                    console.error(`Word document with ID ${docId} not found in category.`);
                }
            } else {
                console.error('Category not found.');
            }
        }
    } catch (error) {
        console.error('Error in editing word content:', error);
    }
};

    async function loadPendingContent() {
    const activitiesSnapshot = await getDocs(
        query(
            collection(db, 'activities'),
            orderBy('timestamp', 'desc')
        )
    );

    // Store pending content data in cache
    pendingContentCache = [];
    const tableBody = document.getElementById('pendingContentTableBody');
    tableBody.innerHTML = '';

    const dismissedContent = JSON.parse(localStorage.getItem('dismissedContent')) || [];

    for (const docSnapshot of activitiesSnapshot.docs) {
        const data = docSnapshot.data();
        const docId = docSnapshot.id;

        // Skip dismissed content or approved content
        if (dismissedContent.includes(docId) || data.isApprove) {
            continue;
        }

        let lesson_name = 'N/A';
        let lessonId = data.lessonId || 'N/A';

        if (data.location === 'lesson' && data.lessonId) {
            // For lessons, retrieve lesson name
            const lessonDocRef = doc(db, 'lessons', data.lessonId);
            const lessonDocSnapshot = await getDoc(lessonDocRef);

            if (lessonDocSnapshot.exists()) {
                lesson_name = lessonDocSnapshot.data().lesson_name || 'N/A';
            }
        } else if (data.location === 'category' && data.categoryId) {
            // For categories, retrieve category and subcategory names
            lessonId = data.categoryId; // Use categoryId in place of lessonId

            const categoryDocRef = doc(db, 'categories', data.categoryId);
            const categoryDocSnapshot = await getDoc(categoryDocRef);

            if (categoryDocSnapshot.exists()) {
                const categoryData = categoryDocSnapshot.data();
                lesson_name = data.subcategoryId || 'N/A'; // Display subcategory name if available
            }
        }
        const contentDetails = `
        Word: ${data.word} <br>
        Translated: ${data.translated} <br>
        Options: ${data.options ? data.options.join(', ') : 'No options available'} <br>
    `;
        // Conditionally display buttons based on the action type
        let actionButtons;
        if (data.action === 'Added word in Lesson' || data.action === 'Added word in Category') {
            actionButtons = `
                <button class="approve-btn" data-doc-id="${docId}" onclick="approveContent('${docId}')">Add</button>
                <button class="dismiss-btn" data-doc-id="${docId}" onclick="dismissContent('${docId}')">Dismiss</button>`;
        } else if (data.action === 'Deleted word from Lesson' || data.action === 'Delete word from Category')  {
            actionButtons = `
                <button class="reject-btn" data-doc-id="${docId}" onclick="rejectContent('${docId}')">Delete</button>
                <button class="dismiss-btn" data-doc-id="${docId}" onclick="dismissContent('${docId}')">Dismiss</button>`;
        } else if (data.action === 'Edited word in Lesson'|| data.action === 'Edited word in Category') {
            actionButtons = `
                <button class="edit-btn" data-doc-id="${docId}" data-word-id="${data.wordId}" onclick="editWordContent('${docId}', '${data.wordId}')">Edit</button>
                <button class="dismiss-btn" data-doc-id="${docId}" onclick="dismissContent('${docId}')">Dismiss</button>`;
        } else {
            console.log("Unknown action:", data.action);
            actionButtons = `<button class="dismiss-btn" data-doc-id="${docId}" onclick="dismissContent('${docId}')">Dismiss</button>`;
        }

        const row = document.createElement('tr');
        const imageColumn = `<td><img src="${data.image_path || 'No image available'}" width="100" onclick="openModal('${data.image_path}')"></td>`;

        row.setAttribute('data-doc-id', docId);
        row.innerHTML = `
            <td>${lessonId}</td>
            <td>${lesson_name}</td>
            <td>${contentDetails}</td>
              ${imageColumn}  <!-- Image in its own column -->
            <td style="text-align: center;">${data.action || 'No action made'}</td>
            <td style="text-align: center;">${data.timestamp.toDate().toLocaleString()}</td>
            <td style="text-align: center;" class="status-pending">Pending</td>
            <td>${data.addedBy}</td>
            <td>${actionButtons}</td>
        `;

        tableBody.appendChild(row);
        pendingContentCache.push({ docId, data });
    }
}

    async function loadHistory() {
        const historySnapshot = await getDocs(
            query(
                collection(db, 'history'),
                orderBy('timestamp', 'desc')
            )
        );

        const historyTableBody = document.getElementById('historyTableBody');
        historyTableBody.innerHTML = '';

        for (const historyDoc of historySnapshot.docs) {
            const data = historyDoc.data();
            const row = document.createElement('tr');

            // Apply background color based on adminAction
            if (data.adminAction === 'Deleted content') {
                row.style.backgroundColor = 'red'; // For deleted content
            } else if (data.adminAction === 'Approved content') {
                row.style.backgroundColor = 'green'; // For approved content
            } else if (data.adminAction === 'Edited content') {
                row.style.backgroundColor = 'green'; // For edited content
            } else if (data.adminAction === 'Dismissed content') {
                row.style.backgroundColor = 'gray'; // For dismissed content
            }

            row.innerHTML = `
                <td>${data.timestamp.toDate().toLocaleString()}</td>
                <td>${data.addedBy}</td>
                <td>${data.documentId}</td>
                <td>${data.lessonId}</td>
                <td>${data.contentDetails}</td>
                <td>${data.action}</td>
                <td>${data.adminAction}</td>
            `;
            historyTableBody.appendChild(row);
        }
    }

        document.addEventListener("DOMContentLoaded", loadHistory);
    </script>
    <script src="script.js"></script>
    <script src="trynotif.js"></script>
    </body>
    </html>
